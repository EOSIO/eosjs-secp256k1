<!doctype html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Demonstration of libsecp256k1 compiled with Emscripten</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.js"></script>
    <script type="text/javascript" src="secp256k1.js"></script>
    <script type="text/javascript" src="wordarrayconv.js"></script>
    <style type="text/css">
        form.container>div         { display: table;      }
        form.container>div>p       { display: table-row;  }
        form.container>div>p>label { display: table-cell; padding-right: 0.5em; }
        form.container>div>p>input { display: table-cell; width: 40em; }
    </style>
  </head>
  <body>
    <form id="crypto" class="container" action="#">
        <div>
        <p>
            <label for="msg">Message:</label>
            <input type="text" id="msg" placeholder="Type in message to sign and verify" />
        </p>
        <p>
            <label for="sec">Secret:</label>
            <input type="text" id="sec" placeholder="Secret passphrase from which secret key is derived" />
        </p>
        </div>
        <span id="wait">Waiting for libsecp256k1 to load...</span>
        <input type="submit" id="go" value="Sign and Verify" style="display: none" />
    </form>
    <pre id="out"></pre>

    <script type="text/javascript">
    function go(e)
    {
        var msg_str = document.getElementById("msg").value;
        var sec_str = document.getElementById("sec").value;
        console.log('Go with msg="'+msg_str+'" and sec="'+sec_str+'"');

        var out = document.getElementById("out");
        out.innerText = "";
        function log(s) {
            console.log(s);
            var str;
            if (typeof s === 'object')
            {
                if (s.hasOwnProperty('message'))
                {
                    str = s['message'];
                }
                else
                {
                    str = JSON.stringify(s);
                }
            }
            else
            {
                str = s.toString();
            }
            out.innerText += '\n' + str;
        }

        if (msg_str == "" || sec_str == "")
        {
            log("Error: You must fill in both fields!");
            return;
        }

        var state = {};
        state.message = CryptoJS.enc.u8array.stringify(CryptoJS.SHA256(msg_str));
        state.secret_key = CryptoJS.enc.u8array.stringify(CryptoJS.SHA256(sec_str));
        Promise.resolve()
        .then(function(ret) {
            log("Generated seckey from string: " + sec_str);
            // Second argument to all API functions maps the expected argument name to the alias name
            // under which the expected argument can be found in object passed as the first argument.
            return secp256k1.api.point(state, {seckey: 'secret_key'});
        }).then(function(ret) {
            state.public_key = ret;
            log("Public key is: " + CryptoJS.enc.u8array.parse(state.public_key).toString());
            // The map can also be an Array. In which case, aliases for all expected arguments must be provided
            // in the order defined by the API function.
            return secp256k1.api.ecdsa_sign(state, ['message', 'secret_key']);
        }).then(function(ret) {
            state.sig = ret.sig;
            state.recid = ret.recid;
            log("Signature is: " + CryptoJS.enc.u8array.parse(state.sig).toString());
            log("recid = " + state.recid);
            // If an expected argument name maps to the same name as an alias, there is no need to include it in the map.
            // For example, in this case sig and recid are stored under the same name in state as what the function expects,
            // and therefore the map argument only maps 'msg' to 'message'.
            return secp256k1.api.ecdsa_recover(state, {msg: 'message'});
        }).then(function(ret) {
            state.recovered_pubkey = ret;
            log("Recovered public key is: " + CryptoJS.enc.u8array.parse(state.recovered_pubkey).toString());
            for (var i = 0; i < state.public_key.length; ++i)
            {
                if (state.recovered_pubkey[i] !== state.public_key[i])
                {
                    log("Signature is incorrect.");
                    return;
                }
            }
            log("Signature is correct.");
        }).catch(function(error) {
            log("Error occured: ");
            log(error);
        });
    }

    document.getElementById("crypto").addEventListener("submit", function(e) { e.preventDefault(); });
    secp256k1.init().then(function() {
        document.getElementById("wait").style.display = "none";
        document.getElementById("go").style.display = "block";
        document.getElementById("crypto").addEventListener("submit", go);
        console.log('Loaded');
    });
    </script>
</body>
</html>
